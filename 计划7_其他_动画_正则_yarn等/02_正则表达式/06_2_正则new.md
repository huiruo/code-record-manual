## RegExp
```js
var expression = new RegExp("pattern ", "flags") ;
标志flag的含义：
g ：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；

i ：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；

m ：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。


入参：两个字符串参数
var pattern2 = new RegExp("[bc]at", "i");
```

## RegExp实例方法

1. exec() 方法：

```js
pattern.exec(string);
返回：返回数组，将字符串中匹配正则表达式的结果放到数组中

var text = "mom and dad and baby";
var pattern = /mom( and dad( and baby)?)?/gi;
var matches = pattern.exec(text);    // matches为 ["mom and dad and baby", " and dad and baby", " and baby", index: 0, input: "mom and dad and baby", groups: undefined]
alert(matches.index);                // 0
alert(matches.input);                // "mom and dad and baby"
alert(matches[0]);                   // "mom and dad and baby"
alert(matches[1]);                   // " and dad and baby"
alert(matches[2]);                   // " and baby"
```

规则：对于 exec() 方法
在模式中设置了全局标志（ g ），它每次也只会返回一个匹配项，多次调用exec() ，每次调用则都会在字符串中继续查找新匹配项；
```js
var text = "cat, bat, sat, fat";
var pattern2 = /.at/g;
var matches = pattern2.exec(text);   // 返回数组 ["cat", index: 0, input: "cat, bat, sat, fat", groups: undefined]
alert(matches.index);                // 0
alert(matches[0]);                   // cat
alert(pattern2.lastIndex);           // 3
 
matches = pattern2.exec(text);       // 返回数组 ["bat", index: 5, input: "cat, bat, sat, fat", groups: undefined]
alert(matches.index);                // 5
alert(matches[0]);                   // bat
alert(pattern2.lastIndex);           // 8
```

在不设置全局标志的情况下，在同一个字符串上多次调用 exec() 将始终返回第一个匹配项的信息。
```js
var text = "cat, bat, sat, fat";
var pattern1 = /.at/;
var matches = pattern1.exec(text);    // 返回数组 ["cat", index: 0, input: "cat, bat, sat, fat", groups: undefined] 
alert(matches.index);                 // 0
alert(matches[0]);                    // cat
alert(pattern1.lastIndex);            // 0
 
matches = pattern1.exec(text);
alert(matches.index);                 // 0
alert(matches[0]);                    // cat
alert(pattern1.lastIndex);            // 0
```

## test()
返回：布尔值，检测字符串是否匹配正则表达式
```js
var text = "000-00-0000";
var pattern = /\d{3}-\d{2}-\d{4}/;
if (pattern.test(text)){
    alert("The pattern was matched.");
}
```

```js
/* 实例属性不会重置，所以在循环中再次调用 test() 方法会失败。
 * 第一次调用 test() 找到了 "cat" ，第二次调用是从索引为 3 的字符（上一次匹配的末尾）开始的，所以就找不到它。
 * 测试到字符串末尾，下一次再调用 test() 就又从开头开始。
 */ 
// 字面量实例
var re1 = /cat/g;
for (var i=0; i < 10; i++){
    console.log(re1.test("catastrophe"));  // 结果为 true false true false...
}
 
var re2 = null;
for (var i=0; i < 10; i++){
    re2 = /cat/g;
    console.log(re2.test("catastrophe"));  // 结果为 true true true true...
}
 
// 构造函数实例同理
```

## match方法
该方法接受一个正则作为参数，用来匹配一个字符串，
它的输出结果在不是全局匹配的情况下和exec方法的结果一致即一个数组并带有额外的属性，

如果采用全局匹配，则不返回任何和其被匹配字符串相关的信息，只返回匹配的结果。

非全局匹配代码：
```js
var reg2=/(\w)s(\w)/;
var str2="ws1esr";
var result=str2.match(reg2);
var i=0;

while(result){
	i++;
	if(i<=4){
	console.dir(result);
		console.log("lastIndex:"+reg2.lastIndex);
	}else{
		break;
	}
}

log:
["ws1", "w", "1"]
```

全局匹配代码：
```js
var reg3=/(\w)s(\w)/g;
var str4="ws1estqsa";
console.dir(str4.match(reg3));

log:
["ws1", "est", "qsa"]
```
可以看到，在全局匹配下的时候，它不同于exec方法，它会一次性将所有匹配结果以数组形式返回，且这个数组没有其他属性用来指向被匹配字符串的信息，而exec方法在全局匹配下每次返回的依然是本次匹配的结果数组，且这个数组中只包含本次匹配信息，同时又拥有指向被匹配字符串的信息，即match方法在全局匹配下一次性返回了所有匹配结果，而exec在全局匹配下返回的依然是当次匹配结果。



## 例子：利用 filter+正则表达式对 list进行过滤包括模糊匹配
```js
this.users.filter((item)=>{
　　　　var reg= new RegExp(this.searchText,'i');
　　　　return reg.test(item.name);
});
```
