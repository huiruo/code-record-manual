

### 05.1.ES5 的继承和 ES6 的继承有什么区别 ？

ES5 的继承时通过 prototype 或构造函数机制来实现。

```js
ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上（Parent.apply(this)）

// 解释:
首先，在js中，给对象定义属性有两种方式：//通过执行构造函数设置属性
function A(){
    this.a = 1;
}
//通过原型设置属性
A.prototype.b = 1;所以：一个类Sub要继承另一个类Super，需要继承父类的prototype下的属性，还要执行一下父类的构造函数。
1. 继承prototype下的属性
上面可以看到，Super类的prototype下的属性是没有被继承的，因此下面还需要继承这一部分。
直接「=」肯定不行，因为Sub.prototype中修改属性后，不能影响Super.prototype里面的对象。
function object(o){
    function A(){}
    A.prototype = o
    var ox = new A()
    return ox
}
/*
上面的函数得到的对象ox，拥有了对象o的全部属性（在原型链上），而修改ox的属性，不会影响到o，相当于把o复制了一份。使用object方法，就可以将Super.prototype的属性「复制」到Sub.prototype上了，当然这儿还需要修正一下constructor的指向。
*/
```

ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改 this。

```js
class Person{
      constructor(name,age){  //一,类的构造方法
          this.name=name;
          this.age=age;
      }
      //类的一般方法
      showName(){
          console.log(this.name)
      }
}
//通过extends来实现类的继承
class StarPerson extends Person{
    constructor(name,age,salary){
        super(name,age)  //重点必须的：通过super调用父类的构造方法：调用父类的constructor()
        this.salary=salary;
    }
    showName(){  //父类方法重写
        console.log(this.name,this.age,this.salary)
    }
}
let p1=new StarPerson('name3',25,200)  //重点：对应的
console.log(p1)  //StarPerson {name: "name3", age: 25, salary: 200}
p1.showName()	 //name3 25 200
```



### 1.原型链  继承

将一个类型的实例赋值给另一个构造函数的原型。

```js
 function SuperType(){
    this.property = true;
}

SuperType.prototype.getSuperValue = function(){
    return this.property;
};

function SubType(){
    this.subproperty = false;
}

//inherit from SuperType
// 原型链继承父类
SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function (){
    return this.subproperty;
};

var instance = new SubType();
console.log('bb:',instance.getSuperValue());   //bb: true
console.log('aa:',instance.subproperty);   //aa: false
// instanceof用于判断一个变量是否某个对象的实例
console.log(instance instanceof Object);      //true
console.log(instance instanceof SuperType);   //true
console.log(instance instanceof SubType);     //true

console.log(Object.prototype.isPrototypeOf(instance));    //true
console.log(SuperType.prototype.isPrototypeOf(instance)); //true
console.log(SubType.prototype.isPrototypeOf(instance));   //true
```

### 2.构造函数继承:使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）

在子类型构造函数的内部调用超类型构造函数。

```js
// 1。使用父类的构造函数来增强子类实例的缺点：
使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
特点：
解决了1中，子类实例共享父类引用属性的问题
创建子类实例时，可以向父类传递参数
可以实现多继承（call多个父类对象）
缺点：
实例并不是父类的实例，只是子类的实例
只能继承父类的实例属性和方法，不能继承原型属性/方法
无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
//2.正式因为有了上述的缺点，才有了构造函数继承，构造函数继承的核心思想就是SuperClass.call(this,id),直接改变this的指向，使通过this创建的属性和方法在子类中复制一份，因为是单独复制的，所以各个实例化的子类互不影响。但是会造成内存浪费的问题：
function SuperType(){
	console.log('aa:',this)   // aa: SubType {}:因为调用 调用SuperType.call(this)
    this.colors = ["red", "blue", "green"];
}
function SubType(){  
    //inherit from SuperType
    SuperType.call(this);
    // 打印: SubType {colors: Array(3)}
    console.log(this)   // 如果不调用SuperType.call(this) 打印SubType {}
}
let instance1 = new SubType();
instance1.colors.push("black");
console.log(instance1.colors);    //"red,blue,green,black"

let instance2 = new SubType();
console.log(instance2.colors);    //"red,blue,green"

```

### 3.组合式继承

使用原型链实现对原型方法的继承，借用构造函数来实现对实例属性的继承。

```js
function hasPrototypeProperty(object, name) {
    return !object.hasOwnProperty(name) && (name in object);
}
// 父类
function SuperType(name){
    this.name = name;
    this.colors = ["red", "blue", "green"];
}

SuperType.prototype.sayName = function(){
    console.log(this.name);
};
// 子类
function SubType(name, age){  
    SuperType.call(this, name);
    this.age = age;
}
// 1.使用原型链实现对原型方法的继承
SubType.prototype = new SuperType("hehe");

SubType.prototype.sayAge = function(){
    console.log(this.age);
};
// 2.借用构造函数来实现对实例属性的继承
var instance1 = new SubType("Nicholas", 29);
instance1.colors.push("black");
console.log(instance1.colors);  //"red,blue,green,black"
instance1.sayName();      //"Nicholas";
instance1.sayAge();       //29


var instance2 = new SubType("Greg", 27);
console.log(instance2.colors);  //"red,blue,green"
instance2.sayName();      //"Greg";
instance2.sayAge();       //27

//delete instance1.name;
console.log(hasPrototypeProperty(instance1, "colors"));
console.log(hasPrototypeProperty(instance1, "name"));
```

### 4.原型式继承

在object()函数内部，先创建了一个临时性构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。

```js
function object(o){
    function F(){}
    F.prototype = o;
    return new F();
}
let person = {
    name: "Nicholas",
    friends: ["Shelby", "Court", "Van"]
};
let anotherPerson = object(person);
anotherPerson.name = "Greg";
anotherPerson.friends.push("Rob");

let yetAnotherPerson = object(person);
yetAnotherPerson.name = "Linda";
yetAnotherPerson.friends.push("Barbie");

console.log(person.friends);   //"Shelby,Court,Van,Rob,Barbie"
```

### 5.寄生式继承

创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地做了所有工作一样返回对象。

典型的寄生继承：用父类构造函数的proptype创建一个空对象，并将这个对象指向子类构造函数的proptype。

```js
// 例子2：与寄生构造函数和工厂模式类似，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象。
function createAnother(original){
    let clone = Object.create(original);    //通过调用函数创建一个新对象
    clone.sayHi = function(){               //以某种方式来增强这个对象
        console.log("Hi");
    };
    return clone;                        //返回这个对象
}
let person = {
    name: "Bob",
    friends: ["Shelby", "Court", "Van"]
};
let anotherPerson = createAnother(person);
anotherPerson.sayHi();
/*
在上述例子中，createAnother函数接收了一个参数，也就是将要作为新对象基础的对象。
anotherPerson是基于person创建的一个新对象，新对象不仅具有person的所有属性和方法，还有自己的sayHi()方法。
*/
思路与寄生构造函数和工厂模式类似。
新的对象中不仅具有original的所有属性和方法，而且还有自己的sayHi()方法。
寄生式继承在主要考虑对象而不是自定义类型和构造函数的情况下非常有用。
由于寄生式继承为对象添加函数不能做到函数复用，因此效率降低。
```

**寄生继承解释2：**

> 作者：萧强
> 链接：https://www.zhihu.com/question/22232912/answer/56472696
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
>
> **组合继承：**
> 曾经一段时间因为javascript关于类实现继承的不规范，导致各种各样实现继承的代码；而实际上不管代码怎么变，继承都基于两种方式：
> **1.通过原型链，**即子类的原型指向父类的实例从而实现原型共享。
> **2.借用构造函数，**即通过js的apply、call实现子类调用父类的属性、方法；
> 原型链方式可以**实现所有属性方法共享，但无法做到属性、方法独享**（例如Sub1修改了父类的函数，其他所有的子类Sub2、Sub3...想调用旧的函数就无法实现了）；
>
> 而借用构造函数除了能独享属性、方法外还能在子类构造函数中传递参数，但代码无法复用。总体而言就是可以**实现所有属性方法独享，但无法做到属性、方法共享**（例如，Sub1新增了一个函数，然后想让Sub2、Sub3...都可以用的话就无法实现了，只能Sub2、Sub3...各自在构造函数中新增）。
>
> **组合继承就是把以上两种继承方式一起使用**，把共享的属性、方法用原型链继承实现，独享的属性、方法用借用构造函数实现，所以组合继承**几乎**完美实现了js的继承；
> **为什么说是“几乎”？**
>
> 
>
> **因为认(dan)真(teng)的geek们发现组合继承有一个小bug，实现的时候调用了两次超类（父类）**
> **，性能上不合格啊有木有！怎么解决呢？于是“寄生继承”就出来了。**
>
> 
> **寄生继承：**
>
> > 寄生继承的思路跟工厂模式差不多，就是调用一个**仅用于**封装继承过程的函数；
>
> 这个继承思路也是由克罗克福德推广的，没错！就是实现那个**“原型式继承”**的大神。
> （原型式继承就是楼上贴出代码的“object”函数，在很多类库源码中都能发现它的身影）
> 简单而言，**寄生继承就是不用实例化父类了，直接实例化一个临时副本实现了相同的原型链继承。（**即子类的原型指向父类**副本**的实例从而实现原型共享**）**
> **
> 所以“寄生组合继承”用了“寄生继承”修复了“组合继承”的小bug，让js完美实现继承了。**

```js



// 1.实现继承的简单方法
function object(o){
    function F () {};
    F.prototype = o;
    return new F();
}

//2.寄生继承：寄生继承 跟原型继承原理一样， 都是共用原型链，所以不可避免的会污染整个属性。
function inheritPrototype(subType, superType){
    var prototype = object(superType.prototype);
    prototype.constructor = subType;
    subType.prototype = prototype;
}
function testObject() {
var A = function(){}, B = function(){}, a, b;
A.prototype.test_array = [1,2];
A.test_array2 = [3, 4];

inheritPrototype(B, A);
    a = new A();
    b = new B();
    b.test_array.push(45);
    console.log(a.test_array);
}
```



### 6.寄生组合式继承

通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。基本思路：不必为了指定子类型的原型而调用超类型的构造函数。
本质：使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。

```js
//1.组合继承的问题
组合继承最大的问题就是无论在什么情况下，都会调用两次构造函数：一次是在创建子类型原型时，另一次是在子类型构造函数内部:
function SuperType(name){
    this.name = name;
    this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
    alert(this.name);
}

function SubType(name, age){
    SuperType.call(this, name);　　//第二次调用SuperType()
    
    this.age = age;
}
SubType.prototype = new SuperType();　　//第一次调用SuperType()
SubType.prototype.sayAge = function(){
    alert(this.age);
}

/*
在第一次调用SuperType构造函数时，SubType.prototype会得到两个属性： name和colors； 他们都是SuperType的实例属性，只不过现在位于SubType的原型中。
当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。
于是这两个属性就屏蔽了原型中的两个同名属性。
寄生组合式继承就是为了解决这一问题。
*/
//2.寄生组合式继承 解决方案：通过借用构造函数来继承属性；通过原型链来继承方法。不必为了指定子类型的原型而调用超类型的构造函数，
function inheritPrototype(subType, superType){
    let protoType = Object.create(superType.prototype);    //创建对象
    protoType.constructor = subType;                    //增强对象
    subType.prototype = protoType;                        //指定对象
}
function SuperType(name){
    this.name = name;
    this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
    console.log(this.name);  // Bob
}

function SubType(name, age){
    SuperType.call(this, name);　　
    this.age = age;
}

inheritPrototype(SubType, SuperType)
SubType.prototype.sayAge = function(){
    console.log(this.age);   // 18
}
let instance = new SubType("Bob", 18);
instance.sayName();
instance.sayAge();
```



