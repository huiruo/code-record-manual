

### 闭包使用场景：

###### * 1.模仿块级作用域
所谓块级作用域就是指在循环中定义的变量，一旦循环结束，变量也随之销毁，它的作用范围只在这一小块。而在JavaScript中没有这样的块级作用域，由于JavaScript不会告诉你变量是否已经被声明，所以容易造成命名冲突，如果在全局环境定义的变量，就会污染全局环境，因此可以利用闭包的特性来模仿块级作用域。
```js
function X(num) {
    (function(){
        for(var i = 0; i < num.length; i++){
            num++
        }
    }).call() //声明一个函数立即调用以后，浏览器刷新页面会报错，可以用一个小括号把整段函数包起来。
    console.log(i)//undefined
}
在上面的代码中，闭包就是那个匿名函数，这个闭包可以当函数X内部的活动变量，又能保证自己内部的变量在自执行后直接销毁。这种写法经常用在全局环境中，可以避免添加太多全局变量和全局函数，特别是多人合作开发的时候可以减少因此产生的命名冲突等，避免污染全局环境。
```

###### 2.储存变量
闭包的另一个特点是可以保存外部函数的变量，内部函数保留了对外部函数的活动变量的引用，所以变量不会被释放。
```js
function S(){
    var a = 1
    return {
        function(){
            renturn a
        }
    }
}
var d = S() // 100
这种写法可以用在把一些不经常变动计算起来又比较复杂的值保存起来，节省每次的访问时间。
```
###### 封装私有变量
我们可以把函数当作一个范围，函数内部的变量就是私有变量，在外部无法引用，但是我们可以通过闭包的特点来访问私有变量。
```js
var person = function(){
    //变量作用域为函数内部，外部无法访问
    var name = "default";
    return {
        getName : function(){
            return name;
        },
        setName : function(newName){
            name = newName;
        }
    }
}();
print(person.name);//直接访问，结果为undefined
print(person.getName()); // default
person.setName("abruzzi");
print(person.getName()); // abruzzi
```

###### 闭包保存自执行表达式的状态
```js
var elems = document.getElementsByTagName('a');
for (var i = 0; i < elems.length; i++) {
//当点击的时候lockedInIndex不会再改变。
//内部已经执行完毕了，将那个i值保存了下来。
    (function (lockedInIndex) {
        elems[i].addEventListener('click', function (e) {
            e.preventDefault();
            alert('I am link #' + lockedInIndex);
        }, 'false');

    })(i);
}
```
###### Module模式（同样是闭包）
```js
var counter = (function () {
    var i = 0;

    return {
        get: function () {
            return i;
        },
        set: function (val) {
            i = val;
        },
        increment: function () {
            return ++i;
        }
    };
} ());
```
###### 闭包可以让一个变量长期驻扎在内存中，避免全局变量的污染
```js
var res = (function() {
     var count = 29;
     return function add() {
         count++;
         console.log(count);
     }
 })();
 res(); //30
 res(); //31
```

###### 总结： 闭包的本质就是在一个函数内部创建另一个函数。通过函数内的函数的访问变量的的规则 实现在外部访问函数中的变量；
```js
var a = 1;
function dome(){
  var a = 10;
  function fun(){
    console.log(a);
    a++;
  }
  return fun;
}
var wfun = dome();
wfun();
wfun();
wfun();
wfun();
通过执行dome让dome函数中的fun函数抛出，并将其赋值给 wfun 那么wfun中储存的地址就是 dome函数中的 fun函数。

当函数dome执行的时候创建自己的执行期上下文 ，并定义函数fun。fun被的定义时fun的 scope中就有了 doem的执行上下文 以及全局的执行上下文 。当执行函数dome的时候返回函数fun 并用wfun接收。wfun是等于fun的那么他们的 scope中的值也是一样的 。wfun中有一条指向指向了dome的执行期上下文。所以当函数dome执行完的时候 dome的执行期上下文并没有被垃圾回收机制回收。 并且当wfun执行的时候 他的作用域链中有 自己执行期上下文 也有 dome的执行期上下文 以及全局的上下文，当自己没有该变量的时候但是dome中有。所以访问的是dome中的变量，这就涉及到了函数的用域以及作用域链。
```
通俗解析：
```js
当函数可以记住并访问所在的词法作用域， 即函数是在当前词法作用域之外执行， 这时
就产生了闭包.
function a () {  
　　function b () {   //函数b的词法作用域是在函数a内
　　}
　　return b;
}
var c = a();
c(); //此时函数b在它的词法作用域外执行就产生了闭包
```



