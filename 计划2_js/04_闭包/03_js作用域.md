### this对象:this对象是在运行时基于函数的执行环境绑定的
``` 
1.当函数作为对象里的方法被调用时，函数内的this是调用该函数的对象。
2.箭头函数中，函数体内的`this`对象，就是定义时所在作用域的对象，而不是使用时所在的作用域的对象。
3.在调用函数时使用new关键字，this 指向 new 出来的实例对象.(函数内的this是一个全新的对象)
  创建一个新的空的对象
     把这个对象链接到原型对象上
     这个对象被绑定为this
     如果这个函数不返回任何东西，那么就会默认return this
4.如果apply、call或bind方法用于调用、创建一个函数，函数内的 this 就是作为参数传入这些方法的对象。

5.在事件中，this 指向触发这个事件的对象
6.浏览器环境下this的值指向window对象
```

###### 扩展：
```js
Object.call(this,obj1,obj2,obj3) //参数都列出来
Object.apply(this,arguments) //传递给函数的是参数数组
```
使用实例：
```js
function A(){
    
    this.flag = 'A';
    this.tip = function(){
        console.log('log1',this.flag);
    };
}
function B(){
    this.flag = 'B';
}
var a = new A();
var b = new B();
a.tip.apply(b); //or use: a.tip.call(b);
a.tip();
var newFun= a.tip.bind(b) //产生一个新的函数
newFun()
console.log('a',a)
/*
log1 B
log1 A
a A {flag: "A", tip: ƒ}
log1 B
*/
//1.无论是a.tip.call(b);和a.tip.apply(b);运行的结果都是弹出B。
//2.从结果中可以看出call和apply都可以让B对象调用A对象的tip方法，并且修改了this的当前作用对象。
```

###### 扩展1：Function.prototype.bind()
```js
// bind() 最简单的用法是创建一个函数
this.x = 9;    // 在浏览器中，this 指向全局的 "window" 对象
var module = {
    x: 81,
    getX: function() {
        return this.x; 
    }
};
module.getX(); // 81
var retrieveX = module.getX;
retrieveX(); // 返回 9 - 因为函数是在全局作用域中调用的
// 创建一个新函数，把 'this' 绑定到 module 对象
var boundGetX = retrieveX.bind(module);
boundGetX(); // 81
```
###### 扩展2：用apply将数组添加到另一个数组，调用数组的push函数的apply()
```js
var array = ['a', 'b'];
var elements = [0, 1, 2];
array.push.apply(array, elements);
console.info(array); // ["a", "b", 0, 1, 2]
```

###### 扩展：实现深拷贝
方法1：JSON.stringify 把对象转换成字符串，再用 JSON.parse 把字符串转换成新的对象。
```js
var newObject = JSON.parse(JSON.stringify(oldObject));
```
方法2：使用递归的方式实现深拷贝
```js
function _deepClone(source) {
  let target;
  if (typeof source === 'object') {
    target = Array.isArray(source) ? [] : {}
    for (let key in source) {
      if (source.hasOwnProperty(key)) {
        if (typeof source[key] !== 'object') {
          target[key] = source[key]
        } else {
          target[key] = _deepClone(source[key])
        }
      }
    }
  } else {
    target = source
  }
  return target
}
```

###### 什么是作用域链
在JS引擎中，通过标识符查找标识符的值，会从当前作用域向上查找，直到作用域找到第一个匹配的标识符位置。就是JS的作用域链。
```js
var a = 1;
function fn1 () {
    var a = 2;
    function fn2 () {
        var a = 3;
        console.log('log1:',a);
    }
    fn2 ();
}
fn1();
//log1: 3
/*
console.log(a) 语句中，JS在查找 a变量标识符的值的时候，会从 fn2 内部向外部函数查找变量声明，它发现fn2内部就已经有了a变量，那么它就不会继续查找了。那么最终结果也就会打印3了。
*/
```

### 作用域
函数作用域是在函数声明的时候就已经确定了，而函数执行上下文是在函数调用时创建的。
假如一个函数被调用多次，那么它就会创建多个函数执行上下文，但是函数作用域显然不会跟着函数被调用的次数而发生什么变化。

JavaScript虽然是解释执行，但也不是按部就班逐句解释执行的，在真正解释执行之前，JavaScript解释器会预解析代码，将变量、函数声明部分提前解释。
```js
console.log(a); //undefined
var a=3;
console.log(a); //3
console.log(b); //Uncaught ReferenceError: b is not defined
```
每个函数都有自己的执行环境，当执行流进入一个函数的时候，函数的环境会被推入一个函数栈中，而在函数执行完毕后执行环境出栈并被销毁，保存在其中的所有变量和函数定义随之销毁，控制权返回到之前的执行环境中，全局的执行环境在应用程序退出（浏览器关闭）才会被销毁。

嵌套函数作用域：在外层函数中，嵌套一个内层函数，那么这个内层函数可以向上访问到外层函数中的变量。
```js
function outer () {
    var thing = '吃早餐';
    function inner () {
        console.log(thing);
    }
    inner();
}
outer();  // 吃早餐
```
既然内层函数可以访问到外层函数的变量，那如果把内层函数return出来会怎样？
```js
function outer () {
    var thing = '吃早餐';
    
    function inner () {
        console.log(thing);
    }
    
    return inner;
}

var foo = outer();
foo();  // 吃早餐

前面提到，函数执行完后，函数作用域的变量就会被垃圾回收。而这段代码看出当返回了一个访问了外部函数变量的内部函数，最后外部函数的变量得以保存。
这种当变量存在的函数已经执行结束，但扔可以再次被访问到的方式就是“闭包”。
```

