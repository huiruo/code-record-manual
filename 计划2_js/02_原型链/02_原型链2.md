### 创建对象的方式
###### 1.字面量：效率比较高
```text
{}是字面量，可以立即求值，而new Object()本质上是方法（只不过这个方法是内置的）调用，既然是方法调用，就涉及到在proto链中遍历该方法，当找到该方法后，又会生产方法调用必须的堆栈信息，方法调用结束后，还要释放该堆栈
```
###### 2.new 分为构造函数和class---->new一个对象经历了什么?
总结：使用new运算符会创建一个新的对象，它继承自构造函数的prototype,也就是说它的__proto__属性会指向构造函数的prototype
new Object() 也就是具有构造函数的内置Object的实例，新创建的对象的__proto__属性会指向Object的prototype
```js
function Test(){}
const objTest = new Test()
```
```
1.创建一个空对象，然后设置新对象的constructor属性为构造函数的名称，设置新对象的**proto**属性指向构造函数的prototype对象。
var objTest = {};  // 01.创建一个空对象
objTest.constructor = Test
objTest.__proto__ = Test.prototype

2.使用新对象调用函数，函数中的this被指向新实例对象
Test.call(objTest)

3.将初始化完毕的新对象地址，保存到等号左边的变量中
创建一个新的空的对象
把这个对象链接到原型对象上
这个对象被绑定为this
如果这个函数不返回任何东西，那么就会默认return this

/*
1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2、属性和方法被加入到 this 引用的对象中。
3、新创建的对象由 this 所引用，并且最后隐式的返回this。
*/
```
###### 3.Object.create()
Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__

```js
const person = {
  isHuman: false,
  printIntroduction: function() {
    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
  }
};

const me = Object.create(person);

me.name = 'Matthew'; // "name" is a property set on "me", but not on "person"
me.isHuman = true; // inherited properties can be overwritten

me.printIntroduction();
// expected output: "My name is Matthew. Am I human? true"
```
具体三个步骤就是：
```js
1. 创建一个对象
2. 继承指定父对象
3. 为新对象扩展新属性
//自己实现一个Object.create()：
Object.myCreate = function (obj, properties)  {
  var F = function ()  {}
  F.prototype = obj
  if (properties) {
     Object.defineProperties(F, properties)
  }
  return new F()
}
Object.myCreate({}, {a: {value: 1}}) //{a: 1}
```

### 关于原型的方法
###### 原型链查找性能:hasOwnProperty是 JavaScript 中唯一一个处理属性并且不会遍历原型链的方法。
```js
const object1 = {
  property1:42
};
console.log(object1.hasOwnProperty('property1'));
// expected output: true
```
###### 扩展：为了遍历一个对象的所有属性时忽略掉继承属性，使用hasOwnProperty()来过滤该对象上的继承属性。
```js
for(let i in dict){
    if(dict.hasOwnProperty(i)){
       console.log(i)
    }
}
```

###### for in 与Object.keys()的区别
```js
Object.keys()：返回一个数组，数组值为对象自有的属性，不会包括继承原型的属性
for in :遍历对象可枚举属性，包括自身属性，以及继承自原型的属性
//实例：
function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype = {
    sex: "男"
}
var man = new Person("张三", 18);
for (var key in man) {
    console.log(key);//name age sex
}
```

### 重点：原型链_原型对象
>只有函数才有prototype,这个属性时一个指针，指向一个对象，它是显示修改对象的原型的属性。当试图访问一个对象的属性时，如果没有在该对象上找到，它还会搜寻该对象的原型(prototype)，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。  准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的`prototype`属性上，而非对象实例本身。

**__proto__和prototype的区别**
__proto__是一个对象的内置属性（请注意：prototype是函数的内置属性，__proto__是对象的内置属性）。
__proto__指向的是当前对象的原型对象，而prototype指向的，是以**当前函数作为构造函数**构造出来的对象 的原型对象。
```js
//简略代码: myA实例的原型指向构造函数的原型
function A() {}
A.prototype.aPrototype='test';

var myA = new A()
console.log('步骤3_是否:',myA.__proto__=== A.prototype) //true

//-A.prototype.constructor (A的原型的构造函数)指向自己
//-A 的原型内容
console.log('A.prototype:',A.prototype) //constructor: ƒ, 包括构造函数:而且构造函数是指向它自己,也就是ƒ A() {}
console.log('A.prototype.constructor',A.prototype.constructor) //ƒ A() {}:A的原型的构造函数是指向它自己,所以是点不完的

//-A的原型的原型指向 Object
console.log('A.prototype.__proto__:',A.prototype.__proto__) //指向Object:{}
console.log('3-2.是否等',A.prototype.__proto__===Object.prototype) //true
//-最终指向null
console.log('A.prototype.__proto__.__proto__:',A.prototype.__proto__.__proto__) //null，所以它就是前面所提到的尽头
```


### 2021.7.15面试_重点

构造函数的__proto__指向什么
```js
function A() {}
A.prototype.aPrototype='test';

var myA = new A()

//步骤1：探究A.constructor 和 A.__proto__
console.log('A.constructor:',A.constructor) //ƒ Function() { [native code] } --->A 的构造函数是 Function
console.log('A.constructor.prototype:',A.constructor.prototype) //ƒ () { [native code] } 
//指向构造A的构造函数Function的原型对象，也就是指向Function.prototype
console.log('A.__proto__:',A.__proto__) //ƒ () { [native code] }
//所以二者相等
console.log('0.是否等',A.__proto__ === A.constructor.prototype) // true

//步骤2：探究 A.prototype 和 A.prototype.constructor
console.log('A',A) // ƒ A() {}
console.log('1.是否等',A.prototype === A.__proto__) //false 肯定不等，两个不是一个东西
console.log('A.prototype:',A.prototype) //constructor: ƒ, 包括构造函数:而且构造函数是指向它自己,也就是ƒ A() {}
console.log('A.prototype.constructor',A.prototype.constructor) //ƒ A() {}:A的原型的构造函数指向自己
console.log('2.是否等',A.prototype.constructor===A) //true
/*
A.prototype就是原型对象。原型对象也是对象，所以它也有proto属性，连接它的原型，
原型对象A.prototype的原型就是Object.prototype这个大boss，所有原型对象都是Object构造函数生成的     
*/

//步骤2：探究 A.prototype.__proto__ 和 object
console.log('A.prototype.__proto__:',A.prototype.__proto__) //指向Object
console.log('3-1.是否等',A.prototype.__proto__===Object) //false,Object 是一个构造函数
console.log('3-2.是否等',A.prototype.__proto__===Object.prototype) //true
console.log('Object',Object) //console.log(Object.prototype) //输出{}
console.log('A.prototype.__proto__.__proto__:',A.prototype.__proto__.__proto__) //null，所以它就是前面所提到的尽头


//步骤3：重点：探究new myA.prototype--->undefined
// 只有函数才有prototype
// myA.__proto__ === A.prototype
/*
prototype是“类”的原型，__proto__是对象的原型。
JS当然没有“类”，只有constructor。
constructor就是当你new fn()时的那个“fn”。
当new的时候，产生的实例的__proto__指向fn.prototype，两者是同一个东西。
*/
function A() {}
A.prototype.aPrototype='test';

var myA = new A()
console.log('myA.__proto__',myA.__proto__) //
/*
{
  aPrototype: "test"
  constructor: ƒ A()
  [[Prototype]]: Object
}
*/
console.log('A.prototype',A.prototype)
console.log('步骤3_是否:',myA.__proto__=== A.prototype) //true
console.log('myA.prototype',myA.prototype) //undefine :函数才有prototype
```

###### 扩展2：es6继承和class
```text
1.class 可以理解为function,由于class本质还是一个function,因此它也会拥有一个的prototype属性，当new一个class时，会把class的porototype属性赋值给这个新对象的 __proto属性。
2.constructor 方法是默认添加的方法，在new一个对象时，自动调用该方法，constructor里面定义自己的属性。
3.继承extends和super，class 子类名 extends 父类名实现继承，当然还得在constructor里面写上super(父类的参数)，意思就是在子类中获得父类的this指针，相当于Animal.call(this)，参考
```
```js
class Animal {
 constructor(name,age) {
    console.log("Animal---->",this)
    this.name = name
    this.age = age
}
eat() {
   console.log(this.name + "eat");
}
walk(){
   console.log(this.name + "walk");
 }
}

class Bird extends Animal {
 constructor(name,color,age) {
   //props是继承过来的属性，myAttribute是自己的属性
   //调用实现父类的构造函数,子类必须在constructor方法中调用super方法，否则新建实例时会报错
   super(name,age)//相当于获得父类的this指向,首先调用父类构造函数 Animal.call(this, name);
   console.log("Bird---->",this) //Bird{name: "小燕子", age: 1}
   this.color = color;//父类的属性，也可写在父类中
 }
 fly() {//自己私有的方法
   console.log(this.name + " are friendly to people.");
 }
}
var myBird = new Bird('小燕子','red',1)
myBird.eat()
myBird.fly()
```
