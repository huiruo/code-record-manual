### 继承实例
```js
    //类
    function Animal (name) {
        console.log("父类构造函数----->",this)
        this.name = name || 'Animal';
        this.sleep = function(){
            console.log(this.name + '正在睡觉！');
        }
        this.getName=function () {console.log(this.name)}
    }
    Animal.prototype.eat = function(food) { //原型方法
        console.log(this.name + '正在吃：' + food);
    };
    // Animal.prototype.getName=function () {console.log(this.name)}

    //1.原型链继承   
    //1.原型链继承:将父类的实例作为子类的原型
    function Cat_1(){ 
    }
    Cat_1.prototype = new Animal();
    Cat_1.prototype.name = 'cat';

    var cat_1 = new Cat_1();
        console.log("A-1:",cat_1.name); //A-1: cat
        console.log("A-2:",cat_1.eat('fish')); //A-2: undefined  ---->cat正在吃：fish
        console.log("A-3:",cat_1.sleep()); //A-3: undefined ---->cat正在睡觉！
        console.log("A-4:",cat_1 instanceof Animal); //A-4: true
        console.log("A-5:",cat_1 instanceof Cat_1); //A-5: true
    /*优点：
        1.非常纯粹的继承关系，实例是子类的实例，也是父类的实例
        2.父类新增原型方法/原型属性，子类都能访问到
        3.简单，易于实现
        */
    /*缺点：
        1.要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中
        2.无法实现多继承
        3.来自原型对象的所有属性被所有实例共享--->致命
        4.创建子类实例时，无法向父类构造函数传参--->致命
        */

        //2:构造继承
        //2:构造继承
        /*
        使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）
        */
        function Cat_2(name){
            console.log("this",this) //Cat_2{}
            Animal.call(this);
            this.name = name || 'Tom';
        }
        var cat_2 = new Cat_2();
        console.log("B-1:",cat_2.name);
        console.log("B-2:",cat_2.sleep()); //B-2: undefined----->Tom正在睡觉！
        console.log("B-3:",cat_2 instanceof Animal); // false
        console.log("B-4:",cat_2 instanceof Cat_2); // true
        /*
        1.解决了1中，子类实例共享父类引用属性的问题
        2.创建子类实例时，可以向父类传递参数
        3.可以实现多继承（call多个父类对象）
        缺点：
        1.实例并不是父类的实例，只是子类的实例
        2.只能继承父类的实例属性和方法，不能继承原型属性/方法
        3.无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
        */

        //3.实例继承
        //3.实例继承:核心：为父类实例添加新特性，作为子类实例返回
        function Cat_3(name){
            var instance = new Animal();
            instance.name = name || 'Tom';
            return instance;
        }

        var cat_3 = new Cat_3();
        console.log("C-1:",cat_3.name);
        console.log("C-2:",cat_3.sleep()); //C-2: undefined---->Tom正在睡觉！
        console.log("C-3:",cat_3 instanceof Animal); // true
        console.log("C-4:",cat_3 instanceof Cat_3); // false
        /*
        不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果
        缺点：
        1.实例是父类的实例，不是子类的实例
        2.不支持多继承
        */

        //4.拷贝继承
        //4.拷贝继承:
        function Cat_4(name){
            var animal = new Animal();
            for(var p in animal){
                Cat_4.prototype[p] = animal[p];
            }
      // 2020年10月10日21点36分：感谢 @baclt 的指出，如下实现修改了原型对象，会导致单个实例修改name，会影响所有实例的name值
      // Cat.prototype.name = name || 'Tom'; 错误的语句，下一句为正确的实现
      this.name = name || 'Tom';
        }
        /*
        特点： 支持多继承
        缺点：
        效率较低，内存占用高（因为要拷贝父类的属性）
        无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）
        */

        var cat_4 = new Cat_4();
        console.log("D-1:",cat_4.name);
        console.log("D-2:",cat_4.sleep());
        console.log("D-3:",cat_4 instanceof Animal); // false
        console.log("D-4:",cat_4 instanceof Cat_4); // true

        //5.组合继承
        //5.组合继承:通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用
        function Cat_5(name){
            Animal.call(this);
            this.name = name || 'Tom';
        }
        Cat_5.prototype = new Animal();
        // 感谢 @学无止境c 的提醒，组合继承也是需要修复构造函数指向的。
        Cat_5.prototype.constructor = Cat_5;

        var cat_5 = new Cat_5();
        console.log("E-1:",cat_5.name);
        console.log("E-2:",cat_5.sleep());
        console.log("E-3:",cat_5 instanceof Animal); // true
        console.log("E-4:",cat_5 instanceof Cat_5); // true
        /*
        特点：
        弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法
        既是子类的实例，也是父类的实例
        不存在引用属性共享问题
        可传参
        函数可复用
        缺点：
        调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）
        */


        //5-1.组合继承2
        /*
        组合式继承将原型链和构造函数的技术组合到一起，结合两者的优点，通过原型链实现对原型属性和方法的继承以及借用构造函数来实现对实例属性的继承。拥有以下的优点:
        1.父类的方法可以被复用
        2.父类的引用属性不会被共享
        3.子类构建实例时可以向父类传递参数
        不过组合式继承中两次调用了父类构造函数
        */
        // 创建子类
        function Cat_5_2(name,sex){
            //构造函数式继承父类属性，这里是第二次调用父类构造函数
            Animal.call(this);
            // 添加子类自己的私有属性
            this.name = name || 'Tom';
            this.sex = sex;
        }
        // 这里是类式继承子类原型继承父类，是第一次调用父类构造函数
   Cat_5_2.prototype = new Animal(); 
   // 将构造函数指向自己
   Cat_5_2.prototype.constructor = Cat_5_2;
   // 添加子类自己的方法
   Cat_5_2.prototype.getsex = function () { console.log(this.sex)}
    // 创建实例
   let sub1 = new Cat_5_2('taec','male')
   console.log("E2-1:",sub1)
   sub1.sleep()  //taec正在睡觉！
   sub1.getsex() //male

   //6.寄生继承 start
   //6.寄生继承:创建一个封装基础过程的函数，该函数内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。
   /*
     寄生式继承因为使用了一个函数以某种形式来增强对象，最后返回对象，那么复用率就不高，导致效率低。
   */
   // 这个方法用于创建一个新对象并且连接原型链
   function object (obj) {
     function F(){}
     F.prototype = obj;
     return new F (); 
   }
   function createson (o,sex) { 
     // 传入父类创建个新对象  
     let newson = object(o)
     // 这里增强对象，添加属性和方法
     newson.sex = sex
     newson.getsex = function () { console.log(this.sex) }
     // 返回对象
     return newson
   }
   console.log("6_1.寄生继承:")
   let sub2 = createson(new Animal(),'famle')
   console.log("6.寄生继承:",sub2)
   sub2.getName()
   sub2.getsex()
   console.log("====================寄生继承end")


        //6.寄生组合继承
        //6.寄生组合继承:核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点
        function Cat_6(name){
            Animal.call(this);
            this.name = name || 'Tom';
        }
        (function(){
      // 创建一个没有实例方法的类
      var Super = function(){};
      Super.prototype = Animal.prototype;
      //将实例作为子类的原型
      Cat_6.prototype = new Super();
        })();

        var cat_6 = new Cat_6();
        console.log("F-1:",cat_6.name);
        console.log("F-2:",cat_6.sleep());
        console.log("F-3:",cat_6 instanceof Animal); // true
        console.log("F-4:",cat_6 instanceof Cat_6); //true
        // 感谢 @bluedrink 提醒，该实现没有修复constructor。
        Cat_6.prototype.constructor = Cat_6; // 需要修复下构造函数

        //6.寄生组合继承写法2 参考：https://www.jianshu.com/p/8ae8dc69fe95
        /*
        了解了组合继承和寄生继承之后就是寄生式组合继承了，它是通过借用构造函数来继承属性，通过原型链形式来继承方法，会解决2次调用父类函数以及复用率的问题。
        这里使用《JavaScript高级程序设计》中的代码来解释继承的方法;
        */
        /*
        可以看到很好的继承了父类的方法和属性以及自己添加属性和方法，并且只调用了1次父类构造函数，同时保证了原型链的完整，是一种理想的继承方法 
        */
         // 实现继承的核心函数
   function inheritPrototype(subType,superType) {
      function F() {};
      //F()的原型指向的是superType
      F.prototype = superType.prototype; 
      //subType的原型指向的是F()
      subType.prototype = new F(); 
      // 重新将构造函数指向自己，修正构造函数
      subType.prototype.constructor = subType; 
   }
   // 设置父类
   function SuperType(name) {
       console.log("寄生组合继承写法2-------->父类构造函数")
       this.name = name;
       this.colors = ["red", "blue", "green"];
       SuperType.prototype.sayName = function () {
         console.log(this.name)
       }
   }
   // 设置子类
   function SubType(name, age) {
        console.log("寄生组合继承写法2-------->子类构造函数")
       //构造函数式继承--子类构造函数中执行父类构造函数
       SuperType.call(this, name);
       this.age = age;
   }
   // 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费
   console.log("寄生组合继承写法2-------->")
   inheritPrototype(SubType, SuperType)
   // 添加子类私有方法
   SubType.prototype.sayAge = function () {
      console.log(this.age);
   }
   SubType.prototype.sayHi = function () {
      console.log("sayHi:",this.age);
   }
   var instance = new SubType("Taec",18)
   console.log("写法2：",instance)
   console.log("写法2：",instance.sayHi())
```


### 1.寄生式继承
创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地做了所有工作一样返回对象。

典型的寄生继承：用父类构造函数的proptype创建一个空对象，并将这个对象指向子类构造函数的proptype。
```js
// 例子2：与寄生构造函数和工厂模式类似，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象。
function createAnother(original){
    let clone = Object.create(original);    //通过调用函数创建一个新对象
    clone.sayHi = function(){               //以某种方式来增强这个对象
        console.log("Hi");
    };
    return clone;                        //返回这个对象
}
let person = {
    name: "Bob",
    friends: ["Shelby", "Court", "Van"]
};
let anotherPerson = createAnother(person);
anotherPerson.sayHi();
/*
在上述例子中，createAnother函数接收了一个参数，也就是将要作为新对象基础的对象。
anotherPerson是基于person创建的一个新对象，新对象不仅具有person的所有属性和方法，还有自己的sayHi()方法。
*/
```
### 2.寄生组合式继承
通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。基本思路：不必为了指定子类型的原型而调用超类型的构造函数。
本质：使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。
```js
//2.寄生组合式继承 解决方案：通过借用构造函数来继承属性；通过原型链来继承方法。不必为了指定子类型的原型而调用超类型的构造函数，
function inheritPrototype(subType, superType){
    let protoType = Object.create(superType.prototype);    //创建对象
    protoType.constructor = subType;         //增强对象
    subType.prototype = protoType;           //指定对象
}
function SuperType(name){
    this.name = name;
    this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){
    console.log(this.name);  // Bob
}

function SubType(name, age){
    SuperType.call(this, name);　　
    this.age = age;
}

inheritPrototype(SubType, SuperType)
SubType.prototype.sayAge = function(){
    console.log(this.age);   // 18
}
let instance = new SubType("Bob", 18);
instance.sayName();
instance.sayAge();
```

### 3 个用于拓展原型链的方法
下面列举四种用于拓展原型链的方法，以及他们的优势和缺陷。下列四个例子都创建了完全相同的 `inst` 对象（所以在控制台上的输出也是一致的），为了举例，唯一的区别是他们的创建方法不同。
#### 1.原型
```js
function foo(){

}
console.log('aa:')
foo.prototype = {
	foo_prop: "foo val"
};
function bar(){
	console.log('bb:')
}
var proto = new foo();
proto.bar_prop = "bar val";
bar.prototype = proto;
var inst = new bar();
console.log(inst.foo_prop);
console.log(inst.bar_prop);
```
优势
支持目前以及所有可想象到的浏览器(IE5.5都可以使用). 这种方法非常快，非常符合标准，并且充分利用JIST优化。

缺陷
为使用此方法，这个问题中的函数必须要被初始化。 在这个初始化过程中，构造可以存储一个唯一的信息，并强制在每个对象中生成。但是，这个一次性生成的独特信息，可能会带来潜在的问题。另外，构造函数的初始化，可能会给生成对象带来并不想要的方法。 然而，如果你只在自己的代码中使用，你也清楚（或有通过注释等写明）各段代码在做什么，这些在大体上都根本不是问题（事实上，还常常是有益处的）。

#### 2.Object.create
Object.create(proto，[propertiesObject])
proto，新创建对象的原型对象。
propertiesObject,可选。需要传入一个对象，该对象的属性类型参照Object.defineProperties()的第二个参数。

```js
function foo(){}
	foo.prototype = {
	foo_prop: "foo val"
};
function bar(){}
var proto = Object.create(foo.prototype);

proto.bar_prop = "bar val";
bar.prototype = proto;
var inst = new bar;
console.log(inst.foo_prop);
console.log(inst.bar_prop);

//例子2：
function foo(){}
foo.prototype = {
    foo_prop: "foo val"
};
function bar(){}

var proto = Object.create(foo.prototype, {bar_prop: {value: "bar val"}});
bar.prototype = proto;
var inst = new bar;
console.log(inst.foo_prop);
console.log(inst.bar_prop)
```
优势：

支持当前所有非微软版本或者 IE9 以上版本的浏览器。允许一次性地直接设置 `__proto__` 属性，以便浏览器能更好地优化对象。同时允许通过 `Object.create(null) `来创建一个没有原型的对象。

缺陷：
不支持 IE8 以下的版本。然而，随着微软不再对系统中运行的旧版本浏览器提供支持，这将不是在大多数应用中的主要问题。 另外，这个慢对象初始化在使用第二个参数的时候有可能成为一个性能黑洞，因为每个对象的描述符属性都有自己的描述对象。当以对象的格式处理成百上千的对象描述的时候，可能会造成严重的性能问题。

#### 3.Object.setPrototypeOf()   es5
Object.setPrototypeOf(obj, prototype) 
obj 要设置其原型的对象。.
prototype 该对象的新原型(一个对象 或 null).
```js
function foo(){}
foo.prototype = {
    foo_prop: "foo val"
};
function bar(){}
var proto = {
    bar_prop: "bar val"
};
Object.setPrototypeOf(
    proto, foo.prototype
);

bar.prototype = proto;
var inst = new bar;
console.log(inst.foo_prop);
console.log(inst.bar_prop);

//例子2：
//例子2：
function foo(){}
    foo.prototype = {
    foo_prop: "foo val"
};

function bar(){}
var proto;
proto=Object.setPrototypeOf({ bar_prop: "bar val" }, foo.prototype);

bar.prototype = proto;
var inst = new bar;
console.log(inst.foo_prop);
console.log(inst.bar_prop)
```
