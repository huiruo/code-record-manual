<!DOCTYPE html>
<html>
<head>
	<title>hello world</title>
</head>
<body>
	<div>
		<span id="extends1" style="cursor: pointer;">原型链继承</span>
		<span id="extends2" style="cursor: pointer;">继承</span>
		<span id="extends3" style="cursor: pointer;">继承</span>
	</div>
	<script type="text/javascript">
		document.getElementById('extends1').onclick=function(){
   		// testClick()
   		console.log("extends1")
   	};
   	document.getElementById('extends2').onclick=function(){
   		// testClick()
   		console.log("extends2")
   	};
   	document.getElementById('extends3').onclick=function(){
   		// testClick()
   		console.log("extends3")
   	};
   	//类
   	function Animal (name) {
   		console.log("父类构造函数----->",this)
   		this.name = name || 'Animal';
   		this.sleep = function(){
   			console.log(this.name + '正在睡觉！');
   		}
   		this.getName=function () {console.log(this.name)}
   	}
   	Animal.prototype.eat = function(food) { //原型方法
   		console.log(this.name + '正在吃：' + food);
   	};
   	// Animal.prototype.getName=function () {console.log(this.name)}

   	//1.原型链继承	
   	//1.原型链继承:将父类的实例作为子类的原型
   	function Cat_1(){ 
   	}
   	Cat_1.prototype = new Animal();
   	Cat_1.prototype.name = 'cat';

   	var cat_1 = new Cat_1();
		console.log("A-1:",cat_1.name); //A-1: cat
		console.log("A-2:",cat_1.eat('fish')); //A-2: undefined  ---->cat正在吃：fish
		console.log("A-3:",cat_1.sleep()); //A-3: undefined ---->cat正在睡觉！
		console.log("A-4:",cat_1 instanceof Animal); //A-4: true
		console.log("A-5:",cat_1 instanceof Cat_1); //A-5: true
   	/*优点：
		1.非常纯粹的继承关系，实例是子类的实例，也是父类的实例
		2.父类新增原型方法/原型属性，子类都能访问到
		3.简单，易于实现
		*/
   	/*缺点：
		1.要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中
		2.无法实现多继承
		3.来自原型对象的所有属性被所有实例共享--->致命
		4.创建子类实例时，无法向父类构造函数传参--->致命
		*/

		//2:构造继承
		//2:构造继承
		/*
		使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）
		*/
		function Cat_2(name){
			console.log("this",this) //Cat_2{}
			Animal.call(this);
			this.name = name || 'Tom';
		}
		var cat_2 = new Cat_2();
		console.log("B-1:",cat_2.name);
		console.log("B-2:",cat_2.sleep()); //B-2: undefined----->Tom正在睡觉！
		console.log("B-3:",cat_2 instanceof Animal); // false
		console.log("B-4:",cat_2 instanceof Cat_2); // true
		/*
		1.解决了1中，子类实例共享父类引用属性的问题
		2.创建子类实例时，可以向父类传递参数
		3.可以实现多继承（call多个父类对象）
		缺点：
		1.实例并不是父类的实例，只是子类的实例
		2.只能继承父类的实例属性和方法，不能继承原型属性/方法
		3.无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
		*/

		//3.实例继承
		//3.实例继承:核心：为父类实例添加新特性，作为子类实例返回
		function Cat_3(name){
			var instance = new Animal();
			instance.name = name || 'Tom';
			return instance;
		}

		var cat_3 = new Cat_3();
		console.log("C-1:",cat_3.name);
		console.log("C-2:",cat_3.sleep()); //C-2: undefined---->Tom正在睡觉！
		console.log("C-3:",cat_3 instanceof Animal); // true
		console.log("C-4:",cat_3 instanceof Cat_3); // false
		/*
		不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果
		缺点：
		1.实例是父类的实例，不是子类的实例
		2.不支持多继承
		*/

		//4.拷贝继承
		//4.拷贝继承:
		function Cat_4(name){
			var animal = new Animal();
			for(var p in animal){
				Cat_4.prototype[p] = animal[p];
			}
	  // 2020年10月10日21点36分：感谢 @baclt 的指出，如下实现修改了原型对象，会导致单个实例修改name，会影响所有实例的name值
	  // Cat.prototype.name = name || 'Tom'; 错误的语句，下一句为正确的实现
	  this.name = name || 'Tom';
		}
		/*
		特点： 支持多继承
		缺点：
		效率较低，内存占用高（因为要拷贝父类的属性）
		无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）
		*/

		var cat_4 = new Cat_4();
		console.log("D-1:",cat_4.name);
		console.log("D-2:",cat_4.sleep());
		console.log("D-3:",cat_4 instanceof Animal); // false
		console.log("D-4:",cat_4 instanceof Cat_4); // true

		//5.组合继承
		//5.组合继承:通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用
		function Cat_5(name){
			Animal.call(this);
			this.name = name || 'Tom';
		}
		Cat_5.prototype = new Animal();
		// 感谢 @学无止境c 的提醒，组合继承也是需要修复构造函数指向的。
		Cat_5.prototype.constructor = Cat_5;

		var cat_5 = new Cat_5();
		console.log("E-1:",cat_5.name);
		console.log("E-2:",cat_5.sleep());
		console.log("E-3:",cat_5 instanceof Animal); // true
		console.log("E-4:",cat_5 instanceof Cat_5); // true
		/*
		特点：
		弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法
		既是子类的实例，也是父类的实例
		不存在引用属性共享问题
		可传参
		函数可复用
		缺点：
		调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）
		*/


		//5-1.组合继承2
		/*
		组合式继承将原型链和构造函数的技术组合到一起，结合两者的优点，通过原型链实现对原型属性和方法的继承以及借用构造函数来实现对实例属性的继承。拥有以下的优点:
		1.父类的方法可以被复用
		2.父类的引用属性不会被共享
		3.子类构建实例时可以向父类传递参数
		不过组合式继承中两次调用了父类构造函数
		*/
		// 创建子类
		function Cat_5_2(name,sex){
			//构造函数式继承父类属性，这里是第二次调用父类构造函数
			Animal.call(this);
			// 添加子类自己的私有属性
			this.name = name || 'Tom';
			this.sex = sex;
		}
		// 这里是类式继承子类原型继承父类，是第一次调用父类构造函数
   Cat_5_2.prototype = new Animal(); 
   // 将构造函数指向自己
   Cat_5_2.prototype.constructor = Cat_5_2;
   // 添加子类自己的方法
   Cat_5_2.prototype.getsex = function () { console.log(this.sex)}
    // 创建实例
   let sub1 = new Cat_5_2('taec','male')
   console.log("E2-1:",sub1)
   sub1.sleep()  //taec正在睡觉！
   sub1.getsex() //male

   //6.寄生继承 start
   //6.寄生继承:创建一个封装基础过程的函数，该函数内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。
   /*
	 寄生式继承因为使用了一个函数以某种形式来增强对象，最后返回对象，那么复用率就不高，导致效率低。
   */
   // 这个方法用于创建一个新对象并且连接原型链
   function object (obj) {
     function F(){}
     F.prototype = obj;
     return new F (); 
   }
   function createson (o,sex) { 
     // 传入父类创建个新对象  
     let newson = object(o)
     // 这里增强对象，添加属性和方法
     newson.sex = sex
     newson.getsex = function () { console.log(this.sex) }
     // 返回对象
     return newson
   }
   console.log("6_1.寄生继承:")
   let sub2 = createson(new Animal(),'famle')
   console.log("6.寄生继承:",sub2)
   sub2.getName()
   sub2.getsex()
   console.log("====================寄生继承end")


		//6.寄生组合继承
		//6.寄生组合继承:核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点
		function Cat_6(name){
			Animal.call(this);
			this.name = name || 'Tom';
		}
		(function(){
	  // 创建一个没有实例方法的类
	  var Super = function(){};
	  Super.prototype = Animal.prototype;
	  //将实例作为子类的原型
	  Cat_6.prototype = new Super();
		})();

		var cat_6 = new Cat_6();
		console.log("F-1:",cat_6.name);
		console.log("F-2:",cat_6.sleep());
		console.log("F-3:",cat_6 instanceof Animal); // true
		console.log("F-4:",cat_6 instanceof Cat_6); //true
		// 感谢 @bluedrink 提醒，该实现没有修复constructor。
		Cat_6.prototype.constructor = Cat_6; // 需要修复下构造函数

		//6.寄生组合继承写法2 参考：https://www.jianshu.com/p/8ae8dc69fe95
		/*
		了解了组合继承和寄生继承之后就是寄生式组合继承了，它是通过借用构造函数来继承属性，通过原型链形式来继承方法，会解决2次调用父类函数以及复用率的问题。
		这里使用《JavaScript高级程序设计》中的代码来解释继承的方法;
		*/
		/*
		可以看到很好的继承了父类的方法和属性以及自己添加属性和方法，并且只调用了1次父类构造函数，同时保证了原型链的完整，是一种理想的继承方法	
		*/
		 // 实现继承的核心函数
   function inheritPrototype(subType,superType) {
      function F() {};
      //F()的原型指向的是superType
      F.prototype = superType.prototype; 
      //subType的原型指向的是F()
      subType.prototype = new F(); 
      // 重新将构造函数指向自己，修正构造函数
      subType.prototype.constructor = subType; 
   }
   // 设置父类
   function SuperType(name) {
   	   console.log("寄生组合继承写法2-------->父类构造函数")
       this.name = name;
       this.colors = ["red", "blue", "green"];
       SuperType.prototype.sayName = function () {
         console.log(this.name)
       }
   }
   // 设置子类
   function SubType(name, age) {
   	   	console.log("寄生组合继承写法2-------->子类构造函数")
       //构造函数式继承--子类构造函数中执行父类构造函数
       SuperType.call(this, name);
       this.age = age;
   }
   // 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费
   console.log("寄生组合继承写法2-------->")
   inheritPrototype(SubType, SuperType)
   // 添加子类私有方法
   SubType.prototype.sayAge = function () {
      console.log(this.age);
   }
   SubType.prototype.sayHi = function () {
      console.log("sayHi:",this.age);
   }
   var instance = new SubType("Taec",18)
   console.log("写法2：",instance)
   console.log("写法2：",instance.sayHi())
</script>
</body>
</html>