/*
* #### 闭包
* 定义：能够读取其他函数内部变量的函数
* 作用：就是让函数外部可以访问函数内部局部变量。
* 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁,闭包的本质就是在一个函数内部创建另一个函数。
* 通过函数内的函数的访问变量的的规则 实现在外部访问函数中的变量
*
* #### 作用域链：函数在执行的过程中，先从自己内部找变量如果找不到，再从创建当前函数所在的作用域(词法作用域)去找, 以 此往上注意找的是变量的当前的状态。
*
* #### 闭包产生
* js中变量的作用域是函数作用域, 在函数执行完后,作用域就会被清理,内存被回收,但是由于闭包函数是建立在函数内部的子函数,
* 子函数可访问上级作用域,即使上级函数执行完, 作用域也不会随之销毁, 即使上级函数执行完后作用域内的值也不会被销毁。
*
* 执行上下文A以及在A中创建的函数B。
* 当B执行时，如果访问了A中的变量对象，那么闭包就会产生。
*/

// 常见创建闭包的方式，在一个函数内部返回一个匿名函数。之所以可以访问内部变量，是因为内部函数的作用域链中包含 fn()的作用域：
// 内部函数被返回，而且是在其他地方被调用了，但它仍然可以访问
function fnTest1(){
    let num = 25
    console.log('被调用')
    return function(){
        return num
    }
}
let fn2 = fnTest1()
console.log(fn2()) // 25
//这证明了，函数 fn 中的局部变量 num 一直保存在内存中，并没有在 fn 调用后被自动清除。

/*
* 例子2：
通过执行dome让dome函数中的fun函数抛出，并将其赋值给 wfun 那么wfun中储存的地址就是 dome函数中的 fun函数。

当函数dome执行的时候创建自己的执行期上下文 ，并定义函数fun。fun被的定义时fun的 scope中就有了 doem的执行上下文 以及全局的执行上下文 。
当执行函数dome的时候返回函数fun 并用wfun接收。wfun是等于fun的那么他们的 scope中的值也是一样的 。wfun中有一条指向指向了dome的执行期上下文。
所以当函数dome执行完的时候 dome的执行期上下文并没有被垃圾回收机制回收。 并且当wfun执行的时候 他的作用域链中有 自己执行期上下文 也有
dome的执行期上下文 以及全局的上下文，当自己没有该变量的时候但是dome中有。所以访问的是dome中的变量，这就涉及到了函数的用域以及作用域链。

通俗解析：
当函数可以记住并访问所在的词法作用域， 即函数是在当前词法作用域之外执行， 这时
就产生了闭包.
* */
var a = 1;
function dome(){
    var a = 10;
    function fun(){
        console.log('通俗解析:',a);
        a++;
    }
    return fun;
}
var wfun = dome();
wfun();
wfun();
wfun();
wfun();

/*
* #### 扩展：函数被调用发生了什么
* 当函数被调用，会创建一个执行环境及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象。但在作用域链中，
* 外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，.....直至作为作用域链终点的全局环境。
*
* 无论什么时候在函数中访问一个变量，就会从作用域链中搜索具有 对应名字的变量。一般当函数执行完毕局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象），但是闭包情况不同。
*
* 在函数内部定义的函数  会将  包含函数的活动对象 添加到 他的作用域链中。当匿名函数被返回后，它的作用域链被初始化为包含 fn()的活动对象和全局变量对象。这样匿名函数就可以访问在fn()中定义的所有变量。
*
* 更为重要的是，fn()执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链让然在引用这个活动对象。换句话说，当fn()函数返回后，其执行环境的作用域链会被销毁，
* 但它的活动对象仍然会留在内存中；直到匿名函数被销毁后，fn()的活动对象才会被销毁。
* */

/*
* 3.闭包面试经典问题
*
* 原因是：setTimeout是异步操作不会马上执行，eventloop会等主线机制完成后执行，
* 需要等待到函数调用栈清空之后才开始执行。即所有可执行代码执行完毕之后，才会开始执行由setTimeout定义的操作。
* 而这些操作进入队列的顺序，则由设定的延迟时间来决定。
因此在上面这个例子中，即使我们将延迟时间设置为0，它定义的操作仍然需要等待所有代码执行完毕之后才开始执行。这里的延迟时间，并非相对于setTimeout执行这一刻，而是相对于其他代码执行完毕这一刻。所以上面的例子执行结果就非常容易理解了。
* 而for是同步执行，因此执行settimeout的时候for循环已经执行完了，结果打印的值为3个3
* */
function testBi(){
    const testArr = [1,2,3]
    for (var i = 0; i < testArr.length; i++) {
        setTimeout(function(){
            console.log('闭包题目：',i)
        },0)
    }
}
testBi() // 输出 333

console.log("分割线=====》")
// 方法1可使用闭包的方法解决
/*
* 解决思路：增加若干个对应的闭包域空间(这里采用的是匿名函数)，
* 专门用来存储原先需要引用的内容(下标)，不过只限于基本类型(基本类型值传递，对象类型引用传递)。
*
* 声明一个匿名函数，若传进来的是基本类型则为值传递，故不会对实参产生影响,
* 该函数对象有一个本地私有变量 arg(形参) ，该函数的 function scope 的 closure 对象属性有两个引用，一个是 arr，一个是 i
* 尽管引用 i 的值随外部改变 ，但本地私有变量(形参) arg 不会受影响，其值在一开始被调用的时候就决定了
* */
function testBi2(){
    const testArr = [1,2,3]
    for (var i = 0; i < testArr.length; i++) {
        (function(arg){       //外部函数
            setTimeout(function(){     //内部函数
                // 只要 外部空间的 arg 不变，这里的引用值当然不会改变
                console.log('闭包题目@：',arg)
            })
        })(i)
    }
}
testBi2() // 输出 1,2,3

// 方法2，使用let
/*
* 遍历 i 是通过 let 关键字声明的：通过 let 和 const 关键字声明的变量是拥有块级作用域（指的是任何在 {} 中的内容）。
* 在每次的遍历过程中，i 都有一个新值，并且每个值都在循环内的作用域中，使其结果依次输出0,1,2
* */

