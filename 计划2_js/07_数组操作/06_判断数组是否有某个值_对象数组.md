

# findIndex() 方法为数组中的每个元素都调用一次函数执行：
```
当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。
如果没有符合条件的元素返回 -1
```

# indexOf()
```
indexOf() 方法可返回数组中某个指定的元素位置。

该方法将从头到尾地检索数组，看它是否含有对应的元素。开始检索的位置在数组 start 处或数组的开头（没有指定 start 参数时）。如果找到一个 item，则返回 item 的第一次出现的位置。开始位置的索引为 0。

如果在数组中没找到指定元素则返回 -1。

```
# 二者对比
```
对比：

1、findIndex()和indexOf方法实现都是通过循环遍历查找。

2、findIndex()的应用场景要比indexOf广泛一些，可以查找大于等于小于，表达式可以随便写，indexOf就只能在第一层查找相等的值。

3、findIndex()实际上相当于一个for循环，只不过找到了你不需要自己退出。

findIndex和indexOf的区别.

indexOf是判断数组中某个元素是否存在,不存在则返回-1
findIndex是用来查找索引的,返回的查找到的符合项的索引.

findOf是传入一个值.找到了也是返回索引,没有找到也是返回-1
findIndex是传入一个测试条件,也就是函数,找到了返回当前项索引,没有找到返回-1.
```

# findIndex
```js
      let arrIndex = this.initTableData.findIndex(item => {
        return item.keyScid === val;
      });
      if (arrIndex > -1) {
        console.log("包含");
        data = this.initTableData[arrIndex].id;
      } else {
        console.log("不包含", arrIndex, this.initTableData[arrIndex]);
        data = val;
      }
```
## 方法2：
```
 handleClose = removedTag => {
    const tags = this.state.tags.filter(tag => tag !== removedTag);
    console.log(tags);
    this.setState({ tags });
  };
```

# indexOf
```js
// e是你要判断是否在这个数组里的元素
let arr = ['1','2','3','4']
let arrIndex = arr.indexOf(e)
if (arrIndex > -1) {
	arr.splice(arrIndex,1)
} else {
	arr.push(e)
}
```
