
#### TCP可靠传输的精髓:
```
TCP连接的一方A，由操作系统动态随机选取一个32位长的序列号（Initial Sequence Number），假设A的初始序列号为1000，
以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B，让B有
一个思想准备，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据
进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。

同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，
2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字
节编号为2001-4000，共2000个字节已经安全到达。
```
双方都需要确认对方收到了自己的序列号
一句话概括，TCP连接握手，握的是啥？

通信双方数据原点的序列号！
以此核心思想我们来分析二、三、四次握手的过程。
##### test:四次握手的过程：
1.1 A 发送同步信号SYN + A's Initial sequence number

1.2 B 确认收到A的同步信号，并记录 A's ISN 到本地，命名 B's ACK sequence number
1.3 B发送同步信号SYN + B's Initial sequence number

1.4 A确认收到B的同步信号，并记录 B's ISN 到本地，命名 A's ACK sequence number

很显然1.2和1.3 这两个步骤可以合并，只需要三次握手，可以提高连接的速度与效率。

```
本质上就是双方要连接，要等待对端同意并返回确认，一端请求后收到确认包就意味着，网络可达并且对端同意建立连接。最后的模型则是

A--请求-->B

A<--确认--B

A<--请求--B

A--确认-->B

中间两次可以一起返回，所以是三次
通俗：
握手和敬军礼一样，源自「敌我双方互相确认对方手里没有武器、无恶意」的仪式。（虽然双方互相请求确认需要四步，但由于中间的确认
和请求是由同一个人执行的，所以合并成了一步）

正恩伸出手说：你看，我手里没有武器。（SYN）
朗普看了看说：嗯，确实没有。（ACK）于是也伸出手说：你看，我手里也没有武器。（SYN）
正恩看了看说：嗯，看来你确实有诚意。（ACK）
于是双方的手握到了一起，随着手上的一阵颤抖，一切变得索然无味……
```

##### test2:二次握手的过程： 
2.1 A 发送同步信号SYN + A's Initial sequence number
2.2 B发送同步信号SYN + B's Initial sequence number + B's ACK sequence number
```
这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信
号丢失了，A和B就B的初始序列号将无法达成一致。

于是TCP的设计者将SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是），既然是一个字节的数据，按照TCP对有数
据的TCP segment 必须确认的原则，所以在这里A必须给B一个确认，以确认A已经接收到B的同步信号。
```

如果A发给B的确认丢了，该如何？
A会超时重传这个ACK吗？不会！TCP不会为没有数据的ACK超时重传。
那该如何是好？B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。

##### 第一个包，即A发给B的SYN 中途被丢，没有到达B
A会周期性超时重传，直到收到B的确认

##### 第二个包，即B发给A的SYN +ACK 中途被丢，没有到达A
B会周期性超时重传，直到收到A的确认
##### 第三个包，即A发给B的ACK 中途被丢，没有到达B
A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：

