> ## 评价一下三种方法实现继承的优缺点,并改进
>
> ```
> function Shape() {}
> 
> function Rect() {}
> 
> // 方法1
> Rect.prototype = new Shape();
> 
> // 方法2
> Rect.prototype = Shape.prototype;
> 
> // 方法3
> Rect.prototype = Object.create(Shape.prototype);
> 
> Rect.prototype.area = function () {
>   // do something
> };
> ```
>
> 方法 1：
>
> 1. 优点：正确设置原型链实现继承
> 2. 优点：父类实例属性得到继承，原型链查找效率提高，也能为一些属性提供合理的默认值
> 3. 缺点：父类实例属性为引用类型时，不恰当地修改会导致所有子类被修改
> 4. 缺点：创建父类实例作为子类原型时，可能无法确定构造函数需要的合理参数，这样提供的参数继承给子类没有实际意义，当子类需要这些参数时应该在构造函数中进行初始化和设置
> 5. 总结：继承应该是继承方法而不是属性，为子类设置父类实例属性应该是通过在子类构造函数中调用父类构造函数进行初始化
>
> 方法 2：
>
> 1. 优点：正确设置原型链实现继承
> 2. 缺点：父类构造函数原型与子类相同。修改子类原型添加方法会修改父类
>
> 方法 3：
>
> 1. 优点：正确设置原型链且避免方法 1.2 中的缺点
> 2. 缺点：ES5 方法需要注意兼容性
>
> 改进：
>
> 1. 所有三种方法应该在子类构造函数中调用父类构造函数实现实例属性初始化
>
> ```
> function Rect() {
>     Shape.call(this);
> }
> ```
>
> 1. 用新创建的对象替代子类默认原型，设置`Rect.prototype.constructor = Rect;`保证一致性
> 2. 第三种方法的 polyfill：
>
> ```js
> function create(obj) {
>     if (Object.create) {
>         return Object.create(obj);
>     }
>     function f() {};
>     f.prototype = obj;
>     return new f();
> }
> ```





> ## 如何进行网站性能优化
>
> [雅虎 Best Practices for Speeding Up Your Web Site](https://developer.yahoo.com/performance/rules.html)：
>
> - content 方面
>   1. 减少 HTTP 请求：合并文件、CSS 精灵、inline Image
>   2. 减少 DNS 查询：DNS 查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS 缓存、将资源分布到恰当数量的主机名，平衡并行下载和 DNS 查询
>   3. 避免重定向：多余的中间访问
>   4. 使 Ajax 可缓存
>   5. 非必须组件延迟加载
>   6. 未来所需组件预加载
>   7. 减少 DOM 元素数量
>   8. 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
>   9. 减少 iframe 数量
>   10. 不要 404
> - Server 方面
>   1. 使用 CDN
>   2. 添加 Expires 或者 Cache-Control 响应头
>   3. 对组件使用 Gzip 压缩
>   4. 配置 ETag
>   5. Flush Buffer Early
>   6. Ajax 使用 GET 进行请求
>   7. 避免空 src 的 img 标签
> - Cookie 方面
>   1. 减小 cookie 大小
>   2. 引入资源的域名不要包含 cookie
> - css 方面
>   1. 将样式表放到页面顶部
>   2. 不使用 CSS 表达式
>   3. 使用不使用@import
>   4. 不使用 IE 的 Filter
> - Javascript 方面
>   1. 将脚本放到页面底部
>   2. 将 javascript 和 css 从外部引入
>   3. 压缩 javascript 和 css
>   4. 删除不需要的脚本
>   5. 减少 DOM 访问
>   6. 合理设计事件监听器
> - 图片方面
>   1. 优化图片：根据实际颜色需要选择色深、压缩
>   2. 优化 css 精灵
>   3. 不要在 HTML 中拉伸图片
>   4. 保证 favicon.ico 小并且可缓存
> - 移动方面
>   1. 保证组件小于 25k
>   2. Pack Components into a Multipart Document

> 1. 







> ## HTTP request 报文结构是怎样的
>
> [rfc2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html)中进行了定义：
>
> 1. 首行是**Request-Line**包括：**请求方法**，**请求 URI**，**协议版本**，**CRLF**
> 2. 首行之后是若干行**请求头**，包括**general-header**，**request-header**或者**entity-header**，每个一行以 CRLF 结束
> 3. 请求头和消息实体之间有一个**CRLF 分隔**
> 4. 根据实际请求需要可能包含一个**消息实体** 一个请求报文例子如下：
>
> ```http
> GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
> Host: www.w3.org
> Connection: keep-alive
> Cache-Control: max-age=0
> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
> User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36
> Referer: https://www.google.com.hk/
> Accept-Encoding: gzip,deflate,sdch
> Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
> Cookie: authorstyle=yes
> If-None-Match: "2cc8-3e3073913b100"
> If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT
> 
> name=qiu&age=25
> ```
>
> ## HTTP response 报文结构是怎样的
>
> [rfc2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html)中进行了定义：
>
> 1. 首行是状态行包括：**HTTP 版本，状态码，状态描述**，后面跟一个 CRLF
> 2. 首行之后是**若干行响应头**，包括：**通用头部，响应头部，实体头部**
> 3. 响应头部和响应实体之间用**一个 CRLF 空行**分隔
> 4. 最后是一个可能的**消息实体** 响应报文例子如下：
>
> ```http
> HTTP/1.1 200 OK
> Date: Tue, 08 Jul 2014 05:28:43 GMT
> Server: Apache/2
> Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
> ETag: "40d7-3e3073913b100"
> Accept-Ranges: bytes
> Content-Length: 16599
> Cache-Control: max-age=21600
> Expires: Tue, 08 Jul 2014 11:28:43 GMT
> P3P: policyref="http://www.w3.org/2001/05/P3P/p3p.xml"
> Content-Type: text/html; charset=iso-8859-1
> 
> {"name": "qiu", "age": 25}
> ```



> ## 下面这段代码想要循环延时输出结果 0 1 2 3 4,请问输出结果是否正确,如果不正确,请说明为什么,并修改循环内的代码使其输出正确结果
>
> ```
> for (var i = 0; i < 5; ++i) {
>   setTimeout(function () {
>     console.log(i + ' ');
>   }, 100);
> }
> ```
>
> 不能输出正确结果，因为循环中 setTimeout 接受的参数函数通过闭包访问变量 i。javascript 运行环境为单线程，setTimeout 注册的函数需要等待线程空闲才能执行，此时 for 循环已经结束，i 值为 5.五个定时输出都是 5 修改方法：将 setTimeout 放在函数立即调用表达式中，将 i 值作为参数传递给包裹函数，创建新闭包
>
> ```js
> for (var i = 0; i < 5; ++i) {
>   (function (i) {
>     setTimeout(function () {
>       console.log(i + ' ');
>     }, 100);
>   }(i));
> }
> ```



> ## 下面这段代码想要循环延时输出结果 0 1 2 3 4,请问输出结果是否正确,如果不正确,请说明为什么,并修改循环内的代码使其输出正确结果
>
> ```
> for (var i = 0; i < 5; ++i) {
>   setTimeout(function () {
>     console.log(i + ' ');
>   }, 100);
> }
> ```
>
> 不能输出正确结果，因为循环中 setTimeout 接受的参数函数通过闭包访问变量 i。javascript 运行环境为单线程，setTimeout 注册的函数需要等待线程空闲才能执行，此时 for 循环已经结束，i 值为 5.五个定时输出都是 5 修改方法：将 setTimeout 放在函数立即调用表达式中，将 i 值作为参数传递给包裹函数，创建新闭包
>
> ```js
> for (var i = 0; i < 5; ++i) {
>   (function (i) {
>     setTimeout(function () {
>       console.log(i + ' ');
>     }, 100);
>   }(i));
> }
> ```