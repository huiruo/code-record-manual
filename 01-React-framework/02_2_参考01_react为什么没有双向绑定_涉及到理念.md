### 标题

> 不实现双向绑定是 React 设计决定:
>
> react 强调一个重要的概念就是数据的不可写，只读数据，state 就是这样的概念，只留了一个 setstate 接口给你调用。
>
> ```
> react最关键的已经帮你自动做了，就是数据驱动渲染，每次state或props更新都会触发render，那么界面上的数据更新，是不是要更改数据模型，这是开发者要考虑的事情，在react的设计模式中，终端组件绝大多数都是无状态组件，页面的操作只会触发一个mutation或action，action才能间接改变数据。如果在一个组件里，需要频繁的写setstate来手动更新状态，这是反设计模式的，如果要频繁更新的状态，首先要放到redux里，其次要通过相应的action去触发更改，这才是react设计的本意。
> ```
>
> 因为 React 的目标从来不是“让开发者写更少的代码”，而是让“代码结构更加清晰易于维护”。
>
> ```
> react为了“代码结构更加清晰易于维护”初学时觉得react的写法 繁琐,到后面就发现了 这种设计的道理。
> ```
>
> 言：说实话我不觉得双向绑定是一个好的设计。
>
> ```
>    react的逻辑是：组件上的io引发change事件，调用onchange回调，onchange回调拿到输入的数据做处理，把结果放入model，引发model的change事件，组件监听model的change事件继而重新渲染组件。
>
>    双向绑定的逻辑是：通过模板中的记号，组件上的最新数据会同步到model中的一个字段中。其他业务逻辑监听这个字段，当字段变化时业务逻辑执行。
> ```
>
> //-------
>
> ```
>    我觉得你是想说为什么react没有在state变化时将data自动同步到dom，在dom value变化时自动同步到state。确实vue内建了这个功能，用起来很爽。
>    react逻辑是state变化就会执行render，这时需要你自己处理数据结构，完成绑定，渲染更自由的view，而view value的变化除了自己监听view事件，没有其他方式感知其变了，它坚持了原生的逻辑，这时你也只能监听你需要的事件，自由的决定要不要更新state，更新哪些state，你会发现此时就形成了闭环，state变化了又是新一轮的render。
> ```

**1.react 实现双向绑定**

```js
import React from "react"
import ReactDOM from "react-dom"

export default class DataBind extends Comonent{
    constructor(){
        super()
        this.state = {
            value: "testVal"
        }
    }
    handleChange(e){
        this.setState({
            value : e.target.value
        )
    }

    render(){
        return(
            <div>
                <input value={this.state.value} onChange={this.handleChange.bind(this)}><input/>
                <p>{this.state.value}<p/>
            <div/>
        )
    }

}
```

**2.vue 双向绑定**

> Vue 内部通过 Object.defineProperty 方法属性拦截的方式，把 data 对象里每个数据的读写转化成 getter/setter，当数据变化时通知视图更新。
>
> 当 data 有变化的时候它通过 Object.defineProperty(）方法中的 set 方法进行监控，并调用在此之前已经定义好 data 和 view 的关系了的回调函数，来通知 view 进行数据的改变
>
> 而 view 发生改变则是通过底层的 input 事件来进行 data 的响应更改
