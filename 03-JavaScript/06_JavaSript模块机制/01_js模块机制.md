
## 模块定义
一个模块用于导出你想要暴露的方法，上下文提供了exports对象就是用来导出的，它也是唯一的出口。
在模块中，还存在一个module对象，它代表模块本身，而exports是module的属性。

## Node中的模块
1.核心模块
核心模块加载的优先级仅次于缓存加载，其加载速度是最快的，因为这些模块在node源代码的编译过程中就已经编译为二进制文件。
如果我们自己编写一个模块，取名为与核心模块相同（如：fs），当我们去引入时自然是不会成功的，除非换成其他的标识符形式引入。
路径形式的文件模块

以…/、./或/开始的标识符，在分析路径模块时，require()方法会将路径转为真实路径，并以真实路径作为索引。由于文件模块
知道了文件的位置，因此加载速度也是比较快的，仅次于核心模块。

2.自定义模块
自定义模块是一类特殊的文件模块，它可能是一个文件或者包的形式，这类模块的查找是最费时的，也是最慢的一种。node在查找
模块时按照模块路径的查找策略，有点类似于JavaScript的原型链一样，逐级向上查找，直到顶级为止。


```
node在引入模块时会经历以下阶段：
（1）路径分析
（2）文件定位
（3）编译执行

模块的加载过程
node在加载模块时会优先从缓存中加载，任何模块在第一次被引入后就会被缓存起来，当第二次引入时，会优先从缓存加载，
与前端浏览器的缓存文件一样以提高性能。不同的是浏览器仅仅缓存文件，而node缓存的是编译和执行后的对象。
```

## 路径分析和文件定位
路径分析就是查找模块所在的路径，由于标识符的形式有多种，因此针对不用形式的标识符在查找和定位上有不同程度的差异。


## JavaScript模块编译
他们是在编译的过程中，Node对JavaScript文件的内容进行了头尾包装。
在头部加上了(function(exports, require, module, __filename, __dirname) {，在尾部加上了})。就像下面这样：
这样做还有一个好处，每个模块之间是相互独立的，不会引起变量污染。
```javascript
(function(exports, require, module, __filename, __dirname) {
//模块文件内容
})
```

## 核心模块的编译过程
node在编译核心模块时，首先把JavaScript代码转存为C/C++代码，采用V8附带的js2c.py工具，转成node_natives.h头文件。
在这个过程中，JavaScript代码以字符串的形式存储在node命名空间中，是不能直接执行的。在启动node进程时，JavaScript代码直接加载进内存中。在加载过程中，JavaScript核心模块经历标识符分析后直接定位到内存中，比普通文件模块查找要快很多。
lib目录下的所有模块文件也是没有定义require、module、exports这些变量的。在引入核心模块的过程中，也经历了头尾包装的过程，然后才执行和导出了exports对象。