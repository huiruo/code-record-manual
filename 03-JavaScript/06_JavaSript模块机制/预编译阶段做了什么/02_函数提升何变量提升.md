
## 变量提升（预解析）
引擎会在解释JavaScript代码之前首先对齐进行编译，编译过程中的一部分工作就是找到所有的声明，并用合适的作用域将他们关联起来，这也正是词法作用域的核心内容。

优点
- 1.提高性能，提前为变量分配空间
- 2.提升容错率

## 函数提升的优先级要高于变量提升
```javaScript
console.log(a); //ƒ a()
console.log(cTest); //ƒ (){ return 3; }
console.log(cTest()) // 3. 说明了函数表达式何函数声明同样会提升
var a = 10;
function a(){
    return 10;
}
console.log(a); // 10;
var cTest =function(){
	return 3;
}
/*
变量名与函数名一致，但是并不会将函数a覆盖
相反的此时的变量a将会被忽略；因为在内存中其实存的仅仅是函数名（变量名）

因为变量a被忽略，所以这里不会打印出来undefined，而是会打印a函数;
*/
```

## 变量提升
使用var定义变量的时候，js解释器会将变量提升到该作用域的最顶部

```
通过let或者const声明的变量会在进入块级作用域的时被创建，但是在该变量没有赋值之前，
引用该变量JavaScript引擎会抛出错误。这就是“暂时性死区”。

在块作用域内，let声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。
```

```javaScript
var a = 10;
var b = 0;
function f1(){
    console.log('test1:',a); // undefined
    console.log('test2:',b); // 0
    var a = 20;     
    console.log(a); // 20
}
f1()

/*
全局作用域并且也赋值了，而在函数f1里面打印的还是undefined，这是因为函数形成的函数作用域，已经是一个封闭性的作用域，只要它里面存在此变量，将不会去访问外层作用域的相同变量了。
*/
```