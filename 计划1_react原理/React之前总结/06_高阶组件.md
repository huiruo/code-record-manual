# 基础实例：
```js
//这是一个无状态组件 TableComponent 
import React from 'react'
import { Table } from './table'   // 高阶函数
const TableComponent = (props) => {
        return (
            <div>
                {props.dataSource}
            </div>
        )
}
export default Table(TableComponent);

//写一个高阶组件，里面写任何需要的生命周期
import React from 'react'
export const Table = (ComposedComponent) => {
    return class extends React.Component {
      constructor(props) {
          super(props)
      }  
      componentDidMount() {
          console.log('componentDidMount');
      }
      render() {
        return (
            <ComposedComponent {...this.props}/>
        )
      }
    }      
}
```

查考：https://www.jianshu.com/p/85f165ca002c
# 高阶函数
```
如果一个函数操作其他函数，即将其他函数作为参数或将函数作为返回值，将其称为高阶函数。
高阶组件(high-order component)类似于高阶函数，接收 React 组件作为输入，输出一个新的 React 组件。高阶组件让代码更具有复用性、逻辑性与抽象特征。可以对 render 方法作劫持，也可以控制 props 与 state。
```

## 高阶组件
```js
1.属性代理(props proxy)。属性组件通过被包裹的 React 组件来操作 props。
2.反向代理(inheritance inversion)。高阶组件继承于被包裹的 React 组件。
```

## 1. 属性代理实现高阶函数
```js
const MyContainer = (WrappedComponent) => {
    return class extends Component {
        render() {
            return (
                <WrappedComponent
                    {...props}
                />
            )
        }
    }
}
export default MyContainer;
```
在 render 方法中返回传入 WrappedComponent 的 React 组件。这样就可以通过高阶组件来传递 props，这种方法即为属性代理。

原始组件想要具备高阶组件对它的修饰，有两种方式。
## 方式一：
```js
export default MyContainer;

class MyComponent extends Component {
}

export default MyContainer(MyComponent);
```

## 方式二：
```js
// ES7 添加了 decorator 的属性，我们可以通过 decorator 来转换，以此简化高阶组件的调用。
@MyContainer
class MyComponent extends Component {
}

export default MyComponent;
```


## 功能上，高阶组件可以控制 props、通过 refs 使用引用、抽象 state 和使用其他元素包裹
### 控制 props
我们可以读取、增加、编辑或是移除从 WrappedComponent 传进来的 props，但需要小心删除与编辑重要的 props。应该尽量对高阶组件的 props 作新的命名以防止混淆。
```js
const MyContainer = (WrappedComponent) => {
    return class extends Component {
        render() {
            const newProps = {
                text: newText
            };
            return (
                <WrappedComponent
                    {...props}
                    {...newProps}
                />
            )
        }
    }
}

export default MyContainer;
```
当调用该高阶组件时，就可以使用 text 这个新的 props了。

### 通过 refs 使用引用
在高阶组件中，可以接受 refs 使用 WrappedComponent 的引用。
```js
const MyContainer = (WrappedComponent) => {
    return class extends Component {
        ref = (view) => {
            view.mentod();
        }
        render() {
            const props = Object.assign({}, this.props, {
                ref: this.ref
            });
            return (
                <WrappedComponent
                    {...props}
                />
            )
        }
    }
}

export default MyContainer;
```
当 WrappedComponent 被渲染时，refs 回调函数就会被执行，这样就会拿到一份 WrappedComponent 实例的引用。这就可以方便地用于读取或增加实例的 props，并调用实例的方法。

* 抽象 state
可以通过 WrappedComponent 提供的 props 和回调函数抽象 state。将原组件抽象为展示型组件，分离内部状态 。
```js
const MyContainer = (WrappedComponent) => {
    return class extends Component {
        constructor(props);
        super(props);
        this.state = {
            name: ''
        };
    }

    onNameChange(text) {
        this.setState({
            name: text
        });
    }

    render() {
        const newProps =  {
            name = {
                value: this.state.name,
                onChangeText: {this.onNameChange}
            }
        }
        return (
            <WrappedComponent
                {...this.props}
                {...newProps}
            />
        );
    }
}
export default MyContainer;
```
使用：
```js
@MyContainer
class MyComponent extends Component {
    render() {
        return (
            <TextInput
                {...this.props.name}
            />
        );
    }
}
```



# 4. 组件参数
调用高阶组件时需要传入一些参数，可以用简单方式实现。
```js
function HOCFactoryFactory(...params) {
    return function HOCFactory(WrappedComponent) {
        return class HOC extends Component {
            render() {
                return (
                    <WrappedComponent 
                        {...this.props}
                    />
                );
            }
        }
    }
}
```
使用：
```js
HOCFactoryFactory(params)(WrappedComponent)

或者

@HOCFactoryFactory(params)
class WrappedComponent extends Component {
}
```

