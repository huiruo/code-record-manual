###### 关于数据流
React中的数据流是单向的，从父组件流向子组件。子组件通过回调函数将数据回送给父组件，但它们不能直接修改父组件的状态，而且父组件也无法直接修改子组件的状态。组件通过属性完成组件交互。
经验实例：
```
1.关于数据流的认识
写组件的时候注意组件的分级，比如：一个父组件，当抽离组件的时候，没有关联数据的时候，应该把他们抽离成兄弟组件，
让组件内维护自己的状态

2.保持数据流的统一性
利用组件流的单向性，可以实现对组件的刷新。

如果我们用全局状态管理(比如mobx),很容易造成数据流的混乱，因为很难追溯源头，状态不可控.

在复杂的应用中,数据多,对于要精确更新的数据，什么能够更新什么，从哪里更新，以及如何更新,我认为应该在源头定义数据，层层往下，避免造成bug.
比如聊天应用中的置顶，消息免打扰操作，这种精细的监听。
```



### 关于组件优化
```
1. 第一考虑是拆分组件， 页面根组件尽量只发起初始化，不使用状态数据，子组件只订阅相关的视图数据

2. 减少子组件的渲染  使用React.memo, 第二个参数 可以接收自定义的比较函数

3. useMemo 用来缓存计算结果数据，斟酌使用，一定不要用来返回jsx（虚拟dom）

4. useCallback 尽量少用，添加不必要的心智负担 和 潜在的bug。原因：
	4.1 好多小伙伴以为使用了useCallback 就减少了子组件渲染，其实单独使用是没什么效果的，需要和memo配合使用。

	4.2 每次函数组件执行，useCallback(callback,deps) ，都创建了一个新的匿名函数callback，只是根据依赖缓存了一个匿名函数。

5. O(n) 的n是dom节点数量，react数据更新 是以当前组件为根节点的 整个组件树，所以 优先拆分组件  优先拆分组件  优先拆分组件，重要的事情说三遍
```

### 关于拆分组件

如果不拆分
```
代码量大，所有内容集中在一起
相同组件无法复用
业务开发分工不明确，开发人员要关心非业务的代码
改代码时，可能会影响其他业务，牵一发动全身(耦合)
任何一个操作都导致整个应用重新render
```

目标：
```
1.架构清晰
2.相同组件能够复用
3.每个组件负责独立的功能，与其他组件解耦合
4.可使用SCU、memo减少不必要渲染
```

```
按状态分，保证每个组件仅有自己最小需要的状态集。组件写大了，其内部状态必然越堆积越多，任何一个状态的改变都会引起整个 function 重新执行。

你明明只需要更新这个组件 10% 的内容，却把整个组件全都计算了一遍。

这当然也有优化方法：优化算法（Virtual Dom），或者拿空间换时间（React.memo）。

但是这些手段都是擦屁股，更合理的方式应该是将状态独立的组件拆分出来。举个例子，你有一个组件，其中一块是要展示一个服务器时间，这个时间的状态其实和整个组件其他的状态都无关，如果不将其拆分，时间变化就会带着整个组件一起计算。

拆分就要拆干净，不要藕断丝连，比如拆出来的组件还是依赖原组件的某些状态，结果通过 props 硬传给他，这就没必要拆了。
```

### react是基于数据是不可变的（每次setState都会返回一个新数据），这也是为什么需要setState()来更新数据而不能使用像vue的this.state = newState的形式更新数据的原因，其实你用this.state=newState确实可以改数据，但是react不知道数据变了

### hooks
```
基础 Hook
	useState
	useEffect
	useContext
额外的 Hook
	useReducer
	useCallback
	useMemo
	useRef
	useImperativeHandle
	useLayoutEffect
	useDebugValue
```

```
useMemo
	帮助程序缓存计算结果
useCallback
	帮助程序缓存函数
```

###### useMemo 实例：
```js
import React, { useState, useMemo } from 'react';
function App() {

  const [count, setCount] = useState(1);
  const [val, setValue] = useState('');

  const expensive = useMemo(() => {
    console.log('compute---->useMemo');
    let sum = 0;
    for (let i = 0; i < count * 100; i++) {
      sum += i;
    }
    return sum;
  }, [count]);

  return (
    <div>
      <h4>{count}-{expensive}</h4>
      {val}
      <div>
        <button onClick={() => setCount(count + 1)}>+c1</button>
        <input value={val} onChange={event => setValue(event.target.value)} />
      </div>
    </div>
  );
}
/*
上面我们可以看到，使用useMemo来执行昂贵的计算，然后将计算值返回，并且将count作为依赖值传递进去。
这样，就只会在count改变的时候触发expensive执行，在修改val的时候，返回上一次缓存的值。
*/
```

###### useCallback
```js
//组件1
import React, { useState, useCallback } from 'react';
import Child from './child'

function App() {
  const [count, setCount] = useState(1);
  const [val, setVal] = useState('');

  const callback = useCallback(() => {
    return count;
  }, [count]);

  return (
    <div className="container">
      父组件
      <h4>{count}</h4>
      <Child callback={callback} />
      <div>
        <button onClick={() => setCount(count + 1)}>+</button>
        <input value={val} onChange={event => setVal(event.target.value)} />
      </div>
    </div>
  );
}

export default App;

//组件2
function Child({ callback }) {

  const [count, setCount] = useState(() => callback());

  useEffect(() => {

    console.log("child旧值：", count)
    console.log("callback()当前值：", callback())

    setCount(callback());

  }, [callback]);

  // useEffect(() => console.log('mounted or updated'));

  return (
    <div>
      子组件：{count}
    </div>
  )
}
export default Child;
```

### 组件优化
在react函数组件中修改状态会触发整个函数组件的重载，重载过程中会导致函数中的方法重载和组件重新渲染，这个过程中有很多重载和重新渲染是不必要的，我们可以使用memo和useCallback方法来阻止不必要的性能消耗

###### memo:作用是在组件重新渲染前确认内部传入的组件是否需要重新渲染。 这里将Pure组件用memo方法进行嵌套
```

```